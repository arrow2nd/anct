// Code generated by github.com/Yamashou/gqlgenc, DO NOT EDIT.

package gen

import (
	"context"
	"net/http"

	"github.com/Yamashou/gqlgenc/clientv2"
)

type Client struct {
	Client *clientv2.Client
}

func NewClient(cli *http.Client, baseURL string, interceptors ...clientv2.RequestInterceptor) *Client {
	return &Client{Client: clientv2.NewClient(cli, baseURL, interceptors...)}
}

type Query struct {
	Node                Node                    "json:\"node,omitempty\" graphql:\"node\""
	Nodes               []Node                  "json:\"nodes\" graphql:\"nodes\""
	SearchCharacters    *CharacterConnection    "json:\"searchCharacters,omitempty\" graphql:\"searchCharacters\""
	SearchEpisodes      *EpisodeConnection      "json:\"searchEpisodes,omitempty\" graphql:\"searchEpisodes\""
	SearchOrganizations *OrganizationConnection "json:\"searchOrganizations,omitempty\" graphql:\"searchOrganizations\""
	SearchPeople        *PersonConnection       "json:\"searchPeople,omitempty\" graphql:\"searchPeople\""
	SearchWorks         *WorkConnection         "json:\"searchWorks,omitempty\" graphql:\"searchWorks\""
	User                *User                   "json:\"user,omitempty\" graphql:\"user\""
	Viewer              *User                   "json:\"viewer,omitempty\" graphql:\"viewer\""
}
type Mutation struct {
	CreateRecord *CreateRecordPayload "json:\"createRecord,omitempty\" graphql:\"createRecord\""
	CreateReview *CreateReviewPayload "json:\"createReview,omitempty\" graphql:\"createReview\""
	DeleteRecord *DeleteRecordPayload "json:\"deleteRecord,omitempty\" graphql:\"deleteRecord\""
	DeleteReview *DeleteReviewPayload "json:\"deleteReview,omitempty\" graphql:\"deleteReview\""
	UpdateRecord *UpdateRecordPayload "json:\"updateRecord,omitempty\" graphql:\"updateRecord\""
	UpdateReview *UpdateReviewPayload "json:\"updateReview,omitempty\" graphql:\"updateReview\""
	UpdateStatus *UpdateStatusPayload "json:\"updateStatus,omitempty\" graphql:\"updateStatus\""
}
type WorkFragment struct {
	AnnictID   int64       "json:\"annictId\" graphql:\"annictId\""
	Title      string      "json:\"title\" graphql:\"title\""
	Media      Media       "json:\"media\" graphql:\"media\""
	SeasonName *SeasonName "json:\"seasonName\" graphql:\"seasonName\""
	SeasonYear *int64      "json:\"seasonYear\" graphql:\"seasonYear\""
}
type CharacterFragment struct {
	Name   string                   "json:\"name\" graphql:\"name\""
	Series CharacterFragment_Series "json:\"series\" graphql:\"series\""
}
type CharacterFragment_Series struct {
	AnnictID int64  "json:\"annictId\" graphql:\"annictId\""
	Name     string "json:\"name\" graphql:\"name\""
}
type SearchWorksByKeyword_SearchWorks struct {
	Nodes []*WorkFragment "json:\"nodes\" graphql:\"nodes\""
}
type SearchCharactersByKeyword_SearchCharacters_Nodes_CharacterFragment_Series struct {
	AnnictID int64  "json:\"annictId\" graphql:\"annictId\""
	Name     string "json:\"name\" graphql:\"name\""
}
type SearchCharactersByKeyword_SearchCharacters struct {
	Nodes []*CharacterFragment "json:\"nodes\" graphql:\"nodes\""
}
type FetchUserLibrary_Viewer_LibraryEntries_Nodes struct {
	Work *WorkFragment "json:\"work\" graphql:\"work\""
}
type FetchUserLibrary_Viewer_LibraryEntries struct {
	Nodes []*FetchUserLibrary_Viewer_LibraryEntries_Nodes "json:\"nodes\" graphql:\"nodes\""
}
type FetchUserLibrary_Viewer struct {
	LibraryEntries *FetchUserLibrary_Viewer_LibraryEntries "json:\"libraryEntries\" graphql:\"libraryEntries\""
}
type SearchWorksByKeyword struct {
	SearchWorks *SearchWorksByKeyword_SearchWorks "json:\"searchWorks\" graphql:\"searchWorks\""
}
type SearchCharactersByKeyword struct {
	SearchCharacters *SearchCharactersByKeyword_SearchCharacters "json:\"searchCharacters\" graphql:\"searchCharacters\""
}
type FetchUserLibrary struct {
	Viewer *FetchUserLibrary_Viewer "json:\"viewer\" graphql:\"viewer\""
}

const SearchWorksByKeywordDocument = `query SearchWorksByKeyword ($keywords: [String!], $seasons: [String!], $first: Int!) {
	searchWorks(titles: $keywords, seasons: $seasons, first: $first, orderBy: {field:SEASON,direction:DESC}) {
		nodes {
			... WorkFragment
		}
	}
}
fragment WorkFragment on Work {
	annictId
	title
	media
	seasonName
	seasonYear
}
`

func (c *Client) SearchWorksByKeyword(ctx context.Context, keywords []string, seasons []string, first int64, interceptors ...clientv2.RequestInterceptor) (*SearchWorksByKeyword, error) {
	vars := map[string]interface{}{
		"keywords": keywords,
		"seasons":  seasons,
		"first":    first,
	}

	var res SearchWorksByKeyword
	if err := c.Client.Post(ctx, "SearchWorksByKeyword", SearchWorksByKeywordDocument, &res, vars, interceptors...); err != nil {
		return nil, err
	}

	return &res, nil
}

const SearchCharactersByKeywordDocument = `query SearchCharactersByKeyword ($keyword: String!, $first: Int!) {
	searchCharacters(names: [$keyword], first: $first, orderBy: {field:FAVORITE_CHARACTERS_COUNT,direction:DESC}) {
		nodes {
			... CharacterFragment
		}
	}
}
fragment CharacterFragment on Character {
	name
	series {
		annictId
		name
	}
}
`

func (c *Client) SearchCharactersByKeyword(ctx context.Context, keyword string, first int64, interceptors ...clientv2.RequestInterceptor) (*SearchCharactersByKeyword, error) {
	vars := map[string]interface{}{
		"keyword": keyword,
		"first":   first,
	}

	var res SearchCharactersByKeyword
	if err := c.Client.Post(ctx, "SearchCharactersByKeyword", SearchCharactersByKeywordDocument, &res, vars, interceptors...); err != nil {
		return nil, err
	}

	return &res, nil
}

const FetchUserLibraryDocument = `query FetchUserLibrary ($state: StatusState!, $first: Int!) {
	viewer {
		libraryEntries(states: [$state], first: $first, orderBy: {direction:DESC,field:LAST_TRACKED_AT}) {
			nodes {
				work {
					... WorkFragment
				}
			}
		}
	}
}
fragment WorkFragment on Work {
	annictId
	title
	media
	seasonName
	seasonYear
}
`

func (c *Client) FetchUserLibrary(ctx context.Context, state StatusState, first int64, interceptors ...clientv2.RequestInterceptor) (*FetchUserLibrary, error) {
	vars := map[string]interface{}{
		"state": state,
		"first": first,
	}

	var res FetchUserLibrary
	if err := c.Client.Post(ctx, "FetchUserLibrary", FetchUserLibraryDocument, &res, vars, interceptors...); err != nil {
		return nil, err
	}

	return &res, nil
}
