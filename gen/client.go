// Code generated by github.com/Yamashou/gqlgenc, DO NOT EDIT.

package gen

import (
	"context"
	"net/http"

	"github.com/Yamashou/gqlgenc/clientv2"
)

type Client struct {
	Client *clientv2.Client
}

func NewClient(cli *http.Client, baseURL string, interceptors ...clientv2.RequestInterceptor) *Client {
	return &Client{Client: clientv2.NewClient(cli, baseURL, interceptors...)}
}

type Query struct {
	Node                Node                    "json:\"node,omitempty\" graphql:\"node\""
	Nodes               []Node                  "json:\"nodes\" graphql:\"nodes\""
	SearchCharacters    *CharacterConnection    "json:\"searchCharacters,omitempty\" graphql:\"searchCharacters\""
	SearchEpisodes      *EpisodeConnection      "json:\"searchEpisodes,omitempty\" graphql:\"searchEpisodes\""
	SearchOrganizations *OrganizationConnection "json:\"searchOrganizations,omitempty\" graphql:\"searchOrganizations\""
	SearchPeople        *PersonConnection       "json:\"searchPeople,omitempty\" graphql:\"searchPeople\""
	SearchWorks         *WorkConnection         "json:\"searchWorks,omitempty\" graphql:\"searchWorks\""
	User                *User                   "json:\"user,omitempty\" graphql:\"user\""
	Viewer              *User                   "json:\"viewer,omitempty\" graphql:\"viewer\""
}
type Mutation struct {
	CreateRecord *CreateRecordPayload "json:\"createRecord,omitempty\" graphql:\"createRecord\""
	CreateReview *CreateReviewPayload "json:\"createReview,omitempty\" graphql:\"createReview\""
	DeleteRecord *DeleteRecordPayload "json:\"deleteRecord,omitempty\" graphql:\"deleteRecord\""
	DeleteReview *DeleteReviewPayload "json:\"deleteReview,omitempty\" graphql:\"deleteReview\""
	UpdateRecord *UpdateRecordPayload "json:\"updateRecord,omitempty\" graphql:\"updateRecord\""
	UpdateReview *UpdateReviewPayload "json:\"updateReview,omitempty\" graphql:\"updateReview\""
	UpdateStatus *UpdateStatusPayload "json:\"updateStatus,omitempty\" graphql:\"updateStatus\""
}
type WorkFragment struct {
	ID                string       "json:\"id\" graphql:\"id\""
	Title             string       "json:\"title\" graphql:\"title\""
	Media             Media        "json:\"media\" graphql:\"media\""
	SeasonName        *SeasonName  "json:\"seasonName\" graphql:\"seasonName\""
	SeasonYear        *int64       "json:\"seasonYear\" graphql:\"seasonYear\""
	EpisodesCount     int64        "json:\"episodesCount\" graphql:\"episodesCount\""
	OfficialSiteURL   *string      "json:\"officialSiteUrl\" graphql:\"officialSiteUrl\""
	ViewerStatusState *StatusState "json:\"viewerStatusState\" graphql:\"viewerStatusState\""
}
type UpdateWorkState_UpdateStatus struct {
	ClientMutationID *string "json:\"clientMutationId\" graphql:\"clientMutationId\""
}
type SearchWorksByKeyword_SearchWorks struct {
	Nodes []*WorkFragment "json:\"nodes\" graphql:\"nodes\""
}
type FetchUserLibrary_Viewer_LibraryEntries_Nodes struct {
	Work *WorkFragment "json:\"work\" graphql:\"work\""
}
type FetchUserLibrary_Viewer_LibraryEntries struct {
	Nodes []*FetchUserLibrary_Viewer_LibraryEntries_Nodes "json:\"nodes\" graphql:\"nodes\""
}
type FetchUserLibrary_Viewer struct {
	LibraryEntries *FetchUserLibrary_Viewer_LibraryEntries "json:\"libraryEntries\" graphql:\"libraryEntries\""
}
type HogeUpdateWorkStatePayload struct {
	UpdateStatus *UpdateWorkState_UpdateStatus "json:\"updateStatus\" graphql:\"updateStatus\""
}
type SearchWorksByKeyword struct {
	SearchWorks *SearchWorksByKeyword_SearchWorks "json:\"searchWorks\" graphql:\"searchWorks\""
}
type FetchUserLibrary struct {
	Viewer *FetchUserLibrary_Viewer "json:\"viewer\" graphql:\"viewer\""
}

const UpdateWorkStateDocument = `mutation UpdateWorkState ($workId: ID!, $state: StatusState!) {
	updateStatus(input: {state:$state,workId:$workId}) {
		clientMutationId
	}
}
`

func (c *Client) UpdateWorkState(ctx context.Context, workID string, state StatusState, interceptors ...clientv2.RequestInterceptor) (*HogeUpdateWorkStatePayload, error) {
	vars := map[string]interface{}{
		"workId": workID,
		"state":  state,
	}

	var res HogeUpdateWorkStatePayload
	if err := c.Client.Post(ctx, "UpdateWorkState", UpdateWorkStateDocument, &res, vars, interceptors...); err != nil {
		return nil, err
	}

	return &res, nil
}

const SearchWorksByKeywordDocument = `query SearchWorksByKeyword ($query: String!, $seasons: [String!], $first: Int!) {
	searchWorks(titles: [$query], seasons: $seasons, first: $first, orderBy: {field:SEASON,direction:DESC}) {
		nodes {
			... WorkFragment
		}
	}
}
fragment WorkFragment on Work {
	id
	title
	media
	seasonName
	seasonYear
	episodesCount
	officialSiteUrl
	viewerStatusState
}
`

func (c *Client) SearchWorksByKeyword(ctx context.Context, query string, seasons []string, first int64, interceptors ...clientv2.RequestInterceptor) (*SearchWorksByKeyword, error) {
	vars := map[string]interface{}{
		"query":   query,
		"seasons": seasons,
		"first":   first,
	}

	var res SearchWorksByKeyword
	if err := c.Client.Post(ctx, "SearchWorksByKeyword", SearchWorksByKeywordDocument, &res, vars, interceptors...); err != nil {
		return nil, err
	}

	return &res, nil
}

const FetchUserLibraryDocument = `query FetchUserLibrary ($states: [StatusState!], $seasons: [String!], $first: Int!) {
	viewer {
		libraryEntries(states: $states, seasons: $seasons, first: $first, orderBy: {direction:DESC,field:LAST_TRACKED_AT}) {
			nodes {
				work {
					... WorkFragment
				}
			}
		}
	}
}
fragment WorkFragment on Work {
	id
	title
	media
	seasonName
	seasonYear
	episodesCount
	officialSiteUrl
	viewerStatusState
}
`

func (c *Client) FetchUserLibrary(ctx context.Context, states []StatusState, seasons []string, first int64, interceptors ...clientv2.RequestInterceptor) (*FetchUserLibrary, error) {
	vars := map[string]interface{}{
		"states":  states,
		"seasons": seasons,
		"first":   first,
	}

	var res FetchUserLibrary
	if err := c.Client.Post(ctx, "FetchUserLibrary", FetchUserLibraryDocument, &res, vars, interceptors...); err != nil {
		return nil, err
	}

	return &res, nil
}
